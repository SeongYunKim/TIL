# B-Tree 인덱스

## 인덱스란?

- ```데이터의 저장(INSERT, UPDATE, DELETE)의 성능을 희생하고 데이터의 읽기 속도를 높이는 기능```

- 칼럼의 값을 주어진 순서로 미리 ```정렬```해서 보관 (like 책의 찾아보기, SortedList)

- 분류 기준

    - 데이터를 저장하는 방식 (알고리즘): B-Tree (칼럼 값 변경 X), Hash (칼럼 값 해싱, 빠른 검색, prefix 검색 불가)

    - 중복 값의 허용 여부: 같은 값이 1개만 존재하는가?, ```옵티마이저에게 중요한 정보```

## B-Tree 인덱스

### B-Tree 구조 및 특성

- Binary X, ```Balanced``` O

- 루트 노드, 브랜치 노드, 리프 노드 (실제 데이터를 찾기 위한 ```주소값```)

- ```인덱스는 키 칼럼만```, 나머지 칼럼은 데이터 파일에서 해당 레코드를 찾아야

- ```인덱스 키 값은 모두 정렬```, 데이터 파일 레코드는 정렬 X (InnoDB는 클러스터되어 저장되므로 레코드도 정렬 O)

### B-Tree 인덱스 키 추가 및 삭제

#### 인덱스 키 추가

- 추가될 B-Tree 상의 적절한 리프 노드 위치를 찾고 디스크의 인덱스 페이지 업데이트 (```쓰기 작업 비용 희생```)

- 대략, (레코드 추가 비용) X 1.5 = (인덱스 키 추가 비용)

- InnoDB: ```인서트 버퍼```를 통한 지연 처리 => 인덱스 키 추가 작업 완료될 때 까지 쿼리 결과를 받지 못하는 문제 해결

#### 인덱스 키 삭제

- 삭제될 B-Tree 상의 리프 노드를 찾아 삭제 마크

#### 인덱스 키 변경

- 키 값만 변경하는 것은 불가능, ```기존 키 삭제 후 새 키 추가```

#### 인덱스 키 검색

- B-Tree 루트 노드부터 최종 리트 노드까지 이동하며 비교 작업 (Tree traversal)

- ```부등호 비교, 뒷 부분 일치, 함수 연산에 의한 변형```은 B-Tree 검색의 장점을 활용 X

### B-Tree 인덱스 사용에 영향을 미치는 요소

#### 인덱스 키 값의 크기

- ```자식 노드의 개수```는 ```인덱스 페이지 크기```와 ```키 값의 크기```에 따라 결정

- 인덱스 ```키 값의 크기 증가``` => 한 페이지에 ```저장할 수 있는 인덱스 개수 감소``` => 디스크로부터 읽어야 할 페이지 수 증가 => 검색 속도 BAD

- 인덱스 ```키 값의 크기 증가``` => 메모리(버퍼 풀, 키 캐시)에 캐시해 둘 레코드 수 감소 => 메모리 효율 BAD

- 인덱스 키 값의 크기는 ```가능하면 작게!```

#### 선택도 (기수성)

- 키 값 가운데 ```유니크한 값의 수```

- ```중복이 많음```(선택도 높음) => 검색 대상이 많음 => ```불필요하게 읽은 레코드가 많음``` => 검색 속도 BAD

- 선택도가 좋지 않더라도 ```정렬, 그룹핑``` 등을 위해 인덱싱 하는 것이 유리할 때도 있음 (인덱스가 항상 검색을 위한 것은 아니다!)

#### 읽어야 하는 레코드 개수

- 인덱스를 통해 필요한 것만 읽기 VS 전체 테이블을 읽고 ```필요 없는 것을 버리기링(필터링)```

- 대략, (테이블에서 직접 레코드 읽는 비용) X 5 = (인덱스를 통해 레코드를 읽는 비용)

- 읽어야 하는 레코드 개수가 20~25%를 넘어가면 필터링 방식 유리

### B-Tree 인덱스를 통해 데이터 읽기

- MySQL이 인덱스를 이용하는 대표적인 방법 3가지 (TBU)

    - 인덱스 레인지 스캔, 인덱스 풀 스캔, 루스 인덱스 스캔

### Multi-column 인덱스

- 두 개 이상의 칼럼을 포함하는 인덱스

- ```두 번째 칼럼은 첫 번째 칼럼에 의존```해서 정렬 (두 번째 칼럼의 정렬은 첫 번째 칼럼이 같은 레코드에서만 의미)

- ```인덱스 내 칼럼의 위치 순서```가 중요!

### B-Tree 인덱스의 가용성과 효율성

#### 비교 조건의 종류와 효율성

- Multi-column 인덱스에서 칼럼의 위치 순서, 사용된 조건(동등 비교(=) vs 범위 조건(<>))에 따라 효율이 다름

- 인덱스 N의 키 값은 인덱스 N-1의 키 값에 대해서 정렬되기 때문에, ```비교 작업의 범위를 좁히는데 도움```(작업 범위 결정 조건) VS  ```쿼리의 조건에 맞는지 검사 용도```(필터링 조건)

#### 인덱스의 가용성

- 왼쪽 값 기준 오른쪽 값이 정렬 => ```왼쪽 부분이 없으면 인덱스 레인지 스캔 불가능``` (```where name like '%성윤'```)

#### 작업 범위 결정 조건으로 B-TREE 인덱스를 사용하지 못하는 조건

- ```NOT-EQUAL``` 비교: <>, NOT IN, NOT BETWEEN, IS NOT NULL

- ```뒷부분 일치``` 비교: LIKE '%~'

- 함수 연산으로 ```인덱스 칼럼이 변형``` 후 비교: SUBSTRING, DAYOFMONTH, ...

#### 작업 범위 결정 조건으로 B-TREE 인덱스를 사용하는 경우

- column_1 ~ column_(i - 1) 까지는 Equal 비교(=, IN)

- column_i 는 =, IN, >, <, LIKE 좌측 일치 패턴

## 느낀 점

공부하기 전에는, 인덱스를 사용하는 이유 정도만 알고 ```빠른 검색이 필요한 칼럼이라면 별 생각 없이 인덱스를 세팅```했던 것 같다. 인덱스의 동작 방식과 성능에 영향을 미치는 다양한 요인들에 대해 모르고
사용하다 보니 불필요한 인덱스도 많았었고, 특히 Multi-Column 인덱스에서 칼럼의 위치 순서를 신경 쓰지 않고 사용했던 적도 많았었다. DB 설계를 할 때 피해갈 수 없는 부분이 인덱스인 만큼 앞으로 인덱스를
세팅할 때는, 정말 해당 칼럼이 인덱스로 세팅되어야 하는가? 작업 범위 결정 조건으로 B-Tree 인덱스를 사용할 수 있는가? 등을 한번 더 생각해보며 결정해야겠다.

### 참고

- Real MySQL 5.2 (인덱스란), 5.3 (B-Tree 인덱스)
