## 가상 메모리

> 복잡하기도 하고 금방금방 까먹는 부분이라 따로 정리해 본다.

- 가상 메모리란?

	- 메모리를 관리하는 방법 중 하나로, 각 프로세스에 실제 메모리 주소가 아닌 **가상의 메모리 주소**(가상/논리 주소)를 주는 방식

	- 메인(실제) 메모리를 2차 저장장치(디스크)를 위한 캐시로 사용

- 가상 메모리의 장점

	- 프로세스 전체가 실제 메모리에 적재되지 않고도 실행이 가능(프로세스가 차지하는 메모리가 전체 메모리 용량보다 크더라도 **현재 필요한 부분만 실제 메모리에 적재**)

	- **메모리가 다수의 프로세스에 의해 공유**되는 것을 가능하도록

	- 실제 물리 메모리의 개념과 **사용자의 논리 메모리의 개념을 분리**(**추상화**)

- 페이지

	- 고정된 크기의 **가상 메모리 블록**
	
	- 가상 주소 = **가상 페이지 번호 + 페이지 오프셋**

	- 실제 주소 = **실제 페이지 번호 + 페이지 오프셋**
	
	- 프로세스를 **페이지의 집합**으로 실제 메모리에 재배치(**연속적인 블록일 필요 X**)

	- **MMU**(**Memory Management Unit**)에 의해 가상 주소가 물리 주소로 변환

- 페이지 테이블

	- **가상 주소 페이지 번호를 인덱스**로, **대응되는 실제 페이지 번호**(실제 메모리 or 디스크)를 가짐

	- 페이지 테이블 레지스터(PTR): 페이지 테이블의 시작 주소를 나타내는 레지스터

	- 유효 비트(valid bit)가 0이면, 페이지는 실제 메모리에 존재X, 디스크에 존재(**페이지 폴트**)

	- 스왑 스페이스(swap space): 프로세스의 모든 페이지를 위한 디스크 상의 공간

	- LRU(Least Recently Used): 실제 메모리 내 모든 페이지가 사용 중일때, 가장 **최근에 덜 사용된 페이지**를 교체, 교체된 페이지는 디스크상의 스왑 스페이스로

- 나중 쓰기 방식
	
	- 디스크 쓰기는 매운 긴 사이클 소요(쓰기 버퍼를 활용한 **즉시 쓰기 방식은 비효율적**)

	- 쓰기는 **실제 메모리상의 페이지에서만** 수행되고, **페이지가 교체될 때만 디스크로 복사**

	- 변경 비트(modify bit 또는 dirty bit)를 활용해 **페이지가 수정되지 않았다면**, 디스크로 복사 없이 **메모리에서 삭제**

- TLB(Translation Lookaside Buffer)
	
	- **페이지 테이블은 메인 메모리**에 저장되기 때문에, 최소한 두번의 메모리 접근 필요(실제 주소 얻기 + 데이터 얻기)

	- 따라서, **최근에 사용된 변환을 추적하는 특별한 캐시(TLB)** 활용

	- TLB 실패 시, 페이지 테이블 탐색
		
		- 실제 메모리에 페이지가 **존재하면? 해당 변환을 TLB에 적재 후 재시도**

		- **존재하지 않으면? 페이지 폴트 발생**(제어를 운영체제에게)